<style>
  body {
    background-color: #222;
    color: #333;
    font-family: 'Inter', sans-serif;
    text-align: center;
    align-content: center;
    align-items: center;
    justify-content: center;
    justify-items: center;
    align-self: center;
    display: flex;
    flex-direction: column;
  }

  #canvas-container {
    border: 0px solid #1f1f1f;
    margin: 0px;
    padding: 0px;
    background-color: #1f1f1f;
    align-content: center;
    align-items: center;
    justify-content: center;
    justify-items: center;
    align-self: center;
    display: flex;
    flex-direction: column;
  }



  .toolbar {
    background-color: #333;
    padding-top: 4px;
    padding-bottom: 5px;
    padding-left: 6px;
    padding-right: 2px;
    border-radius: 0px;
    margin-bottom: 0px;
    margin-top: 12px;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 8px;
    z-index: 11;
  }

  #options-toolbar {
    background-color: #333;
    padding-top: 0px;
    padding-bottom: 0px;
    padding-left: 6px;
    padding-right: 2px;
    border-radius: 0px;
    margin-bottom: 12px;
    margin-top: 6px;
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 8px;
    z-index: 11;
  }

  .active-tool {
    background-color: #000000;
    color: #099AF2;
    border: 1px solid #099AF2;
  }

  button {
    background-color: #444;
    color: #c1c1c1;
    border: 1px solid #555;
    padding-left: 6px;
    padding-right: 6px;
    padding-top: 4px;
    padding-bottom: 4px;
    border-radius: 5px;
    margin-right: 10px;
    font-family: 'Inter', sans-serif;
    cursor: pointer;
    min-width: 24px;
    font-size: 12px;
    font-family: 'Inter', sans-serif;
    color: #999;
    text-transform: uppercase;
    font-weight: semi-bold;
  }

  .copy-btn {
    margin-left: 24px;
  }

  input[type="range"] {
    width: 120px;
    appearance: none;
    background-color: black;
    height: 2px;
  }

  input[type="range"]::-webkit-slider-thumb {
    appearance: none;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: #fff;
    cursor: pointer;
  }

  label {
    font-family: 'Inter', sans-serif;
    color: #888;
    margin-right: 12px;
    margin-left: 6px;
    text-transform: uppercase;
    font-size: 10px;
    font-weight: bold;
    min-width: 24px;
  }

  input[type="color"] {
    width: 40px;
    height: 30px;
    border: 0px solid #999;
    border-radius: 0px;
    background-color: #333;
    color: #333;
    box-shadow: 0 0px 0px rgba(0, 0, 0, 0.2);
    padding: 0px;
    margin-left: 12px;
    margin-right: 12px;
  }

  /* Additional styling for the artboard size inputs */
  .artboard-size-inputs {
    background-color: #2c2c2c;
    padding-top: 6px;
    padding-bottom: 6px;
    border-radius: 0px;
    margin-bottom: 0px;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .artboard-size-inputs label {
    margin-right: 5px;
  }

  .artboard-size-inputs input[type="number"] {
    width: 60px;
    text-align: center;
    border: 0px solid #999;
    background-color: #222;
    color: #999;
    margin-right: 6px;
  }

  #canvas-container {
    position: relative;
  }

  .overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    pointer-events: none;
  }

  .transparent-rectangle {
    width: 512px;
    height: 512px;
    background-color: #fff;
    background-color: transparent;
    pointer-events: none;
    /* Thick border along the outer edge */
    box-shadow: 0 0 0px 1000px rgba(0, 0, 0, 0.75);
    outline: 2px solid transparent;
    z-index: 10;
  }
</style>






<div class="toolbar" id="toolbar">
  <button id="select-mode"><i class="fas fa-mouse-pointer"></i></button>
  <button id="draw-mode" class="active-tool"><i class="fas fa-pencil-alt"></i></button>
  <button id="erase-mode"><i class="fas fa-eraser"></i></button>
  <button id="line-mode"><i class="fas fa-grip-lines"></i></button>


  <button id="copy-button" class="copy-btn"><i class="fas fa-copy"></i> </button>

  <button id="undo-button"><i class="fas fa-undo"></i> </button>
  <button id="redo-button"><i class="fas fa-redo"></i></button>
  <button id="clear-drawing"><i class="fas fa-trash-alt"></i></button>

  <button id="save-image"><i class="fas fa-download"></i></button>
  <button id="add-image"><i class="fas fa-image"></i></button>

  <div class="artboard-size-inputs">
    <label for="artboard-width">Width</label>
    <input type="number" id="artboard-width" value="512">
    <label for="artboard-height">Height</label>
    <input type="number" id="artboard-height" value="512">
  </div>
</div>
<div class="toolbar" id="options-toolbar">
  <label for="brush-width-label">Size</label>
  <input type="range" id="brush-width" min="1" max="250" value="7">
  <label for="brush-width"></label>

  <input type="color" id="brush-color" value="#000000">

  <label for="brush-opacity">Opacity</label>
  <input type="range" id="brush-opacity" min="0" max="1" step="0.1" value="0.8">
  <label id="opacity-size-label"></label>

</div>
<div id="canvas-container">
  <div class="overlay"></div>
  <canvas id="canvas"></canvas>
</div>






<!-- Main js file -->
<script>

  // ===========================================================
  // ===========================================================
  // ELEMENTS & VARIABLES ======================================
  const canvasContainer = document.getElementById('canvas-container');
  const selectModeButton = document.getElementById('select-mode');
  const eraseModeButton = document.getElementById('erase-mode');
  const drawModeButton = document.getElementById('draw-mode');
  const lineModeButton = document.getElementById('line-mode');
  const brushWidthSlider = document.getElementById('brush-width');
  const brushOpacitySlider = document.getElementById('brush-opacity');
  const opacitySizeLabel = document.getElementById('opacity-size-label');
  const brushColorPicker = document.getElementById('brush-color');
  const brushSizeLabel = document.querySelector('label[for="brush-width"]');
  const undoButton = document.getElementById('undo-button');
  const redoButton = document.getElementById('redo-button');
  const clearDrawingButton = document.getElementById('clear-drawing');
  const copyButton = document.getElementById('copy-button');
  const artboardWidthInput = document.getElementById('artboard-width');
  const artboardHeightInput = document.getElementById('artboard-height');
  const addImageButton = document.getElementById('add-image');
  let lines = [];

  // Variables
  const defaultBrushSize = 7;
  let isLineModeActive = false;
  let startPoint = { x: 0, y: 0 };
  let lineInProgress = null;

  // ===========================================================
  // ===========================================================
  // CANVAS & ARTBOARD =========================================
  // Fabric Canvas
  const canvas = new fabric.Canvas('canvas', {
    isDrawingMode: true,
    alignContent: 'center',
    alignItems: 'center',
    justifyContent: 'center',
    width: 712,
    height: 712,
    backgroundColor: '#1f1f1f',
    border: '3px solid #000',
    historyUndo: [], // Array to store undo history
    historyRedo: [], // Array to store redo history
  });

  // Create Artboard
  const artboard = new fabric.Rect({
    width: 512,
    height: 512,
    left: canvas.width / 2 - 256,
    top: canvas.height / 2 - 256,
    fill: 'white',
    stroke: '#999',
    strokeWidth: 1,
    selectable: false,
    evented: false,
    id: 'artboard',
    shadow: 'rgba(0,0,0,1) 0 0px 40px',
  });
  canvas.add(artboard);



  // Update Artboard Size
  function updateArtboardSize() {
    const artboardWidth = parseInt(artboardWidthInput.value);
    const artboardHeight = parseInt(artboardHeightInput.value);

    // Update the artboard size
    artboard.set({
      width: artboardWidth,
      height: artboardHeight,
      left: canvas.width / 2 - artboardWidth / 2,
      top: canvas.height / 2 - artboardHeight / 2,
      selectable: false,
      evented: false,
    });

    // Function to disable artboard selection and edition
    function disableArtboardSelection() {
      artboard.selectable = false;
      artboard.evented = false;
    }

    // Update the transparent rectangle size to match the artboard size
    const transparentRectangle = document.querySelector('.transparent-rectangle');
    transparentRectangle.style.width = artboardWidth + 'px';
    transparentRectangle.style.height = artboardHeight + 'px';

    canvas.renderAll();

  }

  // Update Canvas width and height on input change
  artboardWidthInput.addEventListener('input', function () {
    const width = parseInt(artboardWidthInput.value) + 400;
    canvas.setWidth(width);
    artboard.set({ left: canvas.width / 2 - parseInt(artboardWidthInput.value) / 2 });
    updateArtboardSize();
  });

  artboardHeightInput.addEventListener('input', function () {
    updateArtboardSize();
    const height = parseInt(artboardHeightInput.value) + 200;
    canvas.setHeight(height);
    artboard.set({ top: canvas.height / 2 - parseInt(artboardHeightInput.value) / 2 });
  });

  // Center rectangle within overlay
  document.addEventListener('DOMContentLoaded', function () {
    const transparentRectangle = document.createElement('div');
    transparentRectangle.classList.add('transparent-rectangle');

    const overlay = document.querySelector('.overlay');
    overlay.appendChild(transparentRectangle);

    centerRectangle();
  });

  function centerRectangle() {
    const overlay = document.querySelector('.overlay');
    const rectangle = document.querySelector('.transparent-rectangle');

    const overlayWidth = overlay.offsetWidth;
    const overlayHeight = overlay.offsetHeight;
    const rectangleWidth = rectangle.offsetWidth;
    const rectangleHeight = rectangle.offsetHeight;

    const topOffset = (overlayHeight - rectangleHeight) / 2;
    const leftOffset = (overlayWidth - rectangleWidth) / 2;

    rectangle.style.top = topOffset + 'px';
    rectangle.style.left = leftOffset + 'px';
  }



  //End Canvas & Artboard

  // ===========================================================
  // ===========================================================
  // OPACITY & COLOR ===========================================
  brushOpacitySlider.addEventListener('input', updateBrushOpacityAndColor);
  brushColorPicker.addEventListener('input', updateBrushOpacityAndColor);
  updateBrushOpacityAndColor();

  function updateBrushOpacityAndColor() {
    const brushOpacitySlider = document.getElementById('brush-opacity');
    const brushColorPicker = document.getElementById('brush-color');
    const opacity = brushOpacitySlider.value;
    const color = brushColorPicker.value;
    const rgbaColor = hexToRGBA(color, opacity);
    canvas.freeDrawingBrush.strokeOpacity = opacity;
    canvas.freeDrawingBrush.color = rgbaColor;

    // Update the opacity size label with the current opacity value
    opacitySizeLabel.textContent = opacity;
  }

  function hexToRGBA(hex, opacity) {
    const hexValue = hex.replace("#", "");
    const r = parseInt(hexValue.substring(0, 2), 16);
    const g = parseInt(hexValue.substring(2, 4), 16);
    const b = parseInt(hexValue.substring(4, 6), 16);
    return "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
  }


  // ===========================================================
  // ===========================================================
  // EVENT LISTENERS ===========================================
  // Set active tool
  function setActiveTool(button) {
    const activeToolClass = 'active-tool';
    const activeButton = document.querySelector('.' + activeToolClass);
    if (activeButton) {
      activeButton.classList.remove(activeToolClass);
    }
    button.classList.add(activeToolClass);
  }


  //SELECT MODE ===========================================
  selectModeButton.addEventListener('click', function () {
    //disable line mode
    isLineModeActive = false;
    canvas.isDrawingMode = false;
    canvas.selection = true;

    setActiveTool(selectModeButton);
    //make all objects selectable and evented
    canvas.forEachObject(function (obj) {
      obj.selectable = true;
      obj.evented = true;
    });

    //Below is a hack because I cannot figure out why more than one artboard is created and when this happens.
    //Get all objects with shadow. Make them unselectable and unevented
    const objectsWithShadow = canvas.getObjects().filter(obj => obj.shadow);
    objectsWithShadow.forEach(function (obj) {
      obj.selectable = false;
      obj.evented = false;
    });

    //Get all objects with shadow. Keep one and delete the rest.
    const objectsWithShadowLength = objectsWithShadow.length;
    if (objectsWithShadowLength > 1) {
      for (let i = 1; i < objectsWithShadowLength; i++) {
        canvas.remove(objectsWithShadow[i]);
      }
    }


  });

  // ERASE MODE ===========================================
  eraseModeButton.addEventListener('click', function () {
    canvas.isDrawingMode = true;
    canvas.selection = false;
    canvas.freeDrawingBrush.color = 'white';
    setActiveTool(eraseModeButton);
    //make all objects unselectable
    canvas.forEachObject(function (obj) {
      obj.selectable = false;
    });
    // Disable line mode
    isLineModeActive = false;
  });

  // DRAW MODE ===========================================
  drawModeButton.addEventListener('click', function () {
    isLineModeActive = false; // Disable line mode
    //set color and opacity
    updateBrushOpacityAndColor();
    canvas.isDrawingMode = true;
    canvas.selection = true;
    //Make artboard unselectable and unevented
    artboard.selectable = false;
    artboard.evented = false;
    setActiveTool(drawModeButton);

  });

  // Set Brush Width
  brushWidthSlider.addEventListener('input', function () {
    const size = parseInt(this.value, 10) || 1;
    canvas.freeDrawingBrush.width = size;
    brushSizeLabel.textContent = size;
  });

  opacitySizeLabel.textContent = brushOpacitySlider.value;
  canvas.freeDrawingBrush.width = defaultBrushSize;
  brushWidthSlider.value = defaultBrushSize;
  brushSizeLabel.textContent = defaultBrushSize;


  // LINE MODE ===========================================

  // Line Mode Button event listener
  lineModeButton.addEventListener('click', function () {
    isLineModeActive = !isLineModeActive;
    if (isLineModeActive) {
      setActiveTool(lineModeButton);
      canvas.isDrawingMode = false;
      canvas.selection = false;
      canvas.forEachObject(function (obj) {
        obj.selectable = false;
      });

      // Disable selection for all existing lines when entering Line Mode
      lines.forEach(function (existingLine) {
        existingLine.selectable = false;
      });
    }
  });

  // Mouse down event listener
  canvas.on('mouse:down', function (options) {
    if (isLineModeActive) {
      startPoint = canvas.getPointer(options.e);
      var points = [startPoint.x, startPoint.y, startPoint.x, startPoint.y];

      // Set Line Properties
      const color = brushColorPicker.value;
      const opacity = brushOpacitySlider.value;
      const rgbaColor = hexToRGBA(color, opacity);
      const size = parseInt(brushWidthSlider.value, 10) || 1;

      // Disable artboard and line objects from being selectable while creating lines
      artboard.selectable = false;
      lineInProgress = new fabric.Line(points, {
        strokeWidth: size,
        fill: rgbaColor,
        stroke: rgbaColor,
        originX: 'center',
        originY: 'center',
        selectable: false,
        evented: false
      });
      canvas.add(lineInProgress);
      artboard.sendToBack();
    }
  });

  // Mouse up event listener
  canvas.on('mouse:up', function (options) {
    if (isLineModeActive) {

      // Set Line Properties
      const color = brushColorPicker.value;
      const opacity = brushOpacitySlider.value;
      const rgbaColor = hexToRGBA(color, opacity);
      const size = parseInt(brushWidthSlider.value, 10) || 1;


      var pointer = canvas.getPointer(options.e);
      var points = [startPoint.x, startPoint.y, pointer.x, pointer.y];
      var line = new fabric.Line(points, {
        strokeWidth: size,
        fill: rgbaColor,
        stroke: rgbaColor,
        originX: 'center',
        originY: 'center',
        selectable: false,
        evented: false
      });
      canvas.remove(lineInProgress);
      canvas.add(line);
      canvas.renderAll();
      lineInProgress = null;
      //Make artboard unselectable and unevented
      artboard.selectable = false;
      artboard.evented = false;


      // Disable selection for all existing lines
      lines.forEach(function (existingLine) {
        existingLine.selectable = false;
      });

      // Add the new line to the lines array
      lines.push(line);
    }
    updateCanvasHistory();
  });

  // Mouse move event listener
  canvas.on('mouse:move', function (options) {
    if (isLineModeActive && lineInProgress) { // Check if lineInProgress is not null
      var pointer = canvas.getPointer(options.e);
      lineInProgress.set({ x2: pointer.x, y2: pointer.y });
      canvas.renderAll();
    }
  });

  // Delete Key, Deletes selected object(s)
  document.addEventListener('keydown', function (e) {
    if (e.key === 'Delete') {
      canvas.getActiveObjects().forEach(function (obj) {
        canvas.remove(obj);
      });
    }
  });

  //command-x deletes selected object(s)
  document.addEventListener('keydown', function (e) {
    if ((e.ctrlKey || e.metaKey) && e.key === 'x') {
      canvas.getActiveObjects().forEach(function (obj) {
        canvas.remove(obj);
      });
    }
  });


  // HISTORY ===========================================
  // Update Canvas History
  function updateCanvasHistory() {
    canvas.historyUndo.push(JSON.stringify(canvas));
    canvas.historyRedo = [];
  }

  // Undo Function
  function undo() {
    if (canvas.historyUndo.length > 1) {
      const lastItem = canvas.historyUndo.pop();
      canvas.historyRedo.push(lastItem);
      canvas.loadFromJSON(canvas.historyUndo[canvas.historyUndo.length - 1]);
      canvas.renderAll();
    }
  }

  // Redo Function
  function redo() {
    if (canvas.historyRedo.length > 0) {
      const lastItem = canvas.historyRedo.pop();
      canvas.historyUndo.push(lastItem);
      canvas.loadFromJSON(lastItem);
      canvas.renderAll();
    }

  }

  undoButton.addEventListener('click', undo);
  redoButton.addEventListener('click', redo);

  canvas.on('object:added', updateCanvasHistory);
  canvas.on('object:modified', updateCanvasHistory);
  canvas.on('object:removed', updateCanvasHistory);
  canvas.on('mouse:up', updateCanvasHistory);

  // Command + Z for undo
  document.addEventListener('keydown', function (e) {
    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
      e.preventDefault();
      undo();
    }
  });

  // Command + Shift + Z for redo
  document.addEventListener('keydown', function (e) {
    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && e.shiftKey) {
      e.preventDefault();
      redo();
    }
  });



  // COPY & PASTE ===========================================
  let _clipboard;

  function Copy() {
    canvas.getActiveObject().clone(function (cloned) {
      _clipboard = cloned;
    });
  }

  function Paste() {
    _clipboard.clone(function (clonedObj) {
      canvas.discardActiveObject();
      clonedObj.set({ left: clonedObj.left + 10, top: clonedObj.top + 10, evented: true });

      if (clonedObj.type === 'activeSelection') {
        clonedObj.canvas = canvas;
        clonedObj.forEachObject(function (obj) {
          canvas.add(obj);
        });
        clonedObj.setCoords();
      } else {
        canvas.add(clonedObj);
      }

      _clipboard.top += 10;
      _clipboard.left += 10;
      canvas.setActiveObject(clonedObj);
      canvas.requestRenderAll();
    });
  }

  document.addEventListener('keydown', function (e) {
    if (e.key === 'c' && (e.ctrlKey || e.metaKey)) {
      Copy();
    } else if (e.key === 'v' && (e.ctrlKey || e.metaKey)) {
      Paste();
    }
  });

  // Copy button event listener
  copyButton.addEventListener('click', function () {
    Copy();
    Paste();
  });



  // Clear Drawing button event listener
  document.getElementById('clear-drawing').addEventListener('click', function () {
    canvas.clear();
    canvas.backgroundColor = '#fff';
    canvas.add(artboard);
  });

  //  If item has shadow, make it unselectable and uneditable
  canvas.on('object:added', function (e) {
    if (e.target.shadow) {
      e.target.selectable = false;
      e.target.evented = false;
    }
  });
  //If undo is clicked, check if any items have shadows. Make them unselectable and uneditable.
  canvas.on('object:modified', function (e) {
    if (e.target.shadow) {
      e.target.selectable = false;
      e.target.evented = false;
    }
  });



  // SAVE AS PNG =======================================
  document.getElementById('save-image').addEventListener('click', function () {
    saveCanvasAsImage();
  });

  function saveCanvasAsImage() {
    var dataURL = canvas.toDataURL({
      format: 'png',
      multiplier: 1
    });
    bubble_fn_holder(dataURL);
  }



  // ADD IMAGE =======================================
   addImageButton = document.getElementById('add-image');

  function addImageToCanvas() {
    var imgElement = new Image();

    imgElement.onload = function () {
      var imgInstance = new fabric.Image(imgElement, {
        left: 10,
        top: 10,
      });
      canvas.add(imgInstance);
    };

    imgElement.src = newImageURL;
  }

  addImageButton.addEventListener('click', addImageToCanvas);




</script>
</body>

</html>